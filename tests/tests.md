# Tests

## Idea

Unit tests are particularly important to developers to debug their code separately from other coupling components. These 
unit tests also offer an opportunity to quickly check whether or not the installation of the package was successful, as mentioned 
on the [start page](../README.md#quick-test). 

The remainder of this documentation page focuses on running these tests. The first section explains the procedure to run
(almost) all tests at once, which is useful for the post-installation test. The second section contains information on how to 
include the unit test of a solver wrapper in the testing framework. Lastly, it is explained how to run a single test file,
test class or test method. The latter is useful in the development of a new solver wrappers to quickly test a single 
aspect of the wrapper without having to test all aspects together, which can be time consuming. 

## Running unit tests

### Run all unit tests at once
The unit tests in CoCoNuT uses the  standard unit test module available in Python. To run all the tests (except those 
for the solver wrappers, as will be explained later on), navigate to the _`coconut/tests/`_ directory and type following command 
in the terminal:

````
python -m unittest discover -bv
````
 
The `discover` keyword finds all the unit tests written in the files named _`test*.py`_. It will recursively find all 
the test files with this pattern for all the folders containing an _`__init__.py`_ file. The `-b` keyword suppresses any
output generated by the part of the code that is being tested, unless an error occurs or a test fails. Finally, the 
`-v` keyword enables a higher verbosity, as such the user can see what test methods have been run. Further documentation 
on the Python unit test framework can be found on the [Python documentation website](https://docs.python.org/3/library/unittest.html).

### Including unit tests for solver wrappers 
A solver wrapper provides an interface between the coupling code and an external solver while performing a coupled 
simulation. Since this depends on the availability of the solver in a system, the unit tests for the solver wrappers are 
not run by default. Including the unit tests for solver wrappers in the list of unit tests that need to be run involves 
following steps: 

-   Load the corresponding solver modules in the terminal;
-   Import the test classes for the solver wrappers in the Python file, _`coconyt/tests/solver_wrappers/__init__.py`_;
-   Add the test classes for the solver wrappers in the list called `tests_cases` in the Python file 
_`coconut/tests/solver_wrappers/__init__.py`_.

In practice, the last two steps boil down to simply uncommenting the line that corresponds to the test class of the 
solver  in the `tests_cases` list in the Python file _`coconut/tests/solver_wrappers/__init__.py`_. Be aware that the solver 
wrapper of two different versions of the same software cannot be tested together due to conflicting modules (i.e. only 
one Fluent version at a time can be tested). Compared to the other tests, testing solver wrappers takes more time.

In this way, the test classes (the names on the lines that you uncommented) that are included in the `test_cases` list
are added to the test suite via the `load_tests` function. When you run all tests at once as described above, the
`discovery` option will only run the test classes that are added to the test suite.


### Running unit tests separately
The Python unit test framework allows for running the test separately as well. This is particularly useful for the unit tests
of the solver wrappers, as they generally take a bit longer to run. There are two possibilities: running a test 
on the level of a file, or on the level of the class or even a method. Important is however that you ALWAYS start the test
from the _`coconut/tests/`_ directory! If not, errors will occur due to erroneous paths, especially in the tests of a solver wrapper.

Let us consider the Abaqus unit test as an example. It is located in _`coconut/tests/solver_wrappers/abaqus/test_v614.py`_. In this file
there are two test classes: `TestSolverWrapperAbaqus614Tube2D` and `TestSolverWrapperAbaqus614Tube3D`, which inherits from the former.
Within these test classes, four test methods are run: `test_repeat_iteration`, `test_restart`, `test_partitioning` and 
`test_shear`. The other two methods, `setUpClass` and `setUp`, are run just before each test class and test method, respectively.

If one wants to test this entire file, type following command in the terminal:

````
python -m unittest -bv solver_wrappers/abaqus/test_v614.py
````
 
 This will run both test classes and all four test methods for each test class. The `-b` and `-v` keywords have the same meaning 
 as above. If one wants to test for example only the 2D test class, type the following command in the terminal:
 
````
python -m unittest -bv solver_wrappers.abaqus.test_v614.TestSolverWrapperAbaqus614Tube2D
````

Note the `.` instead of the `/` to separate the folders since now classes are considered rather than files. This command 
will cause Python to run all four test methods from the 2D test class. Finally, it is also possible to run a single 
test method as well. Consider one wants to test only the correct partitioning of the Abaqus solver over multiple cores 
in the 3D test class, type following command in the terminal:

````
python -m unittest -bv solver_wrappers.abaqus.test_v614.TestSolverWrapperAbaqus614Tube3D.test_partitioning
````

Here, only the test method `test_partitioning` is run in the `TestSolverWrapperAbaqus614Tube3D` class. Note that when 
running test classes or test methods of a solver wrapper separately as described in this paragraph, you can discard 
the steps in the previous [paragraph](#including-unit-tests-for-solver-wrappers).