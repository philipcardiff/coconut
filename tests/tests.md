# Tests

## Idea

Unit tests are particularly important to developers to debug their code separately from other coupling components. These 
unit tests also offer an opportunity to quickly check whether the installation of the package was succesful, as mentioned
[here](../README.md). 

The remainder of this documentation page focuses on running these tests. In a first stage, it is explained how you can run
(almost) all tests at once, which is useful for the post-installation test. In a second stage, information is given in how to 
include the unit test of a `solver_wrapper` in the testing framework. Lastly, it is explained how you can run a single test file,
`test_class` or `test_method`. The latter is extremely useful in the development of new `solver_wrappers` as running the complete
unit test is rather time consuming. 

## Running unit tests

### Run all unit tests at once
The unit tests in CoCoNuT uses the  standard unit test module available in Python. To run all the tests (except those 
for the `solver_wrappers`, as will be explained later on), navigate to the `tests/` directory and type following command 
in the terminal:

````
python -m unittest discover -bv
````
 
The `discover` keyword finds all the unit tests written in the files named `test*.py`. It will recursively find all 
the test files with this pattern for all the folders containing an `__init__.py` file. The `-b` keyword suppresses any
output that is generated by the part of the code that is tested, unless an error occurs or a test fails. Finally, the 
`-v` keyword enables a higher verbosity, as such the user can see what `test_methods` have been run. Further documentation 
on the Python unit test framework can be found [here](https://docs.python.org/3/library/unittest.html).

### Including unit tests for solver wrappers 
A `solver_wrapper` provides an interface between the coupling code and an external solver while performing a coupled 
simulation. Since this depends on the availability of the solver in a system, the unit tests for the solver wrappers are 
not run by default. Including the unit tests for solver wrappers in the list of unit tests that need to be run involves 
following steps: 

-   Load the corresponding solver modules in the terminal;
-   Import the `test_classes` for the solver wrappers in the Python file, `tests/solver_wrappers/__init__.py`;
-   Add the `test_classes` for the solver wrappers in the list called `tests_cases` in the Python file 
`tests/solver_wrappers/__init__.py`.

In practice, the last two steps boil down to simply uncommenting the line that corresponds to the `test_class` of the 
solver  in the `tests_cases` list in the Python file `tests/solver_wrappers/__init__.py`. Be aware that the solver 
wrapper of two different versions of the same software can not be tested together due to conflicting modules (i.e. only 
one Fluent version at a time can be tested). Compared to the other tests, testing solver wrappers takes more time.

In this way, the `test_classes` (the names on the lines that you uncommented) that are included in the `test_cases` list
are added to the `test_suite` via the `load_tests` function. When you run all tests at once as described above, the
`discovery` option will for that folder only run the `test_classes` that are explicitly added to the `test_suite`. In case 
this `__init__.py` file is empty, Python will run all `test_classes` that can be found in `test*.py` files in that folder.
In case the `test_classes` list is defined but left empty, no `test_classes` are executed.

### Running unit tests separately
The Python unit test framework allows for running the test separately as well. This is particularly useful for the unit tests
of the solver wrappers, as they generally take a bit longer to run. There are two possibilities: running a test 
on the level of a file, or on the level of the class or even a method. Important is however that you ALWAYS start the test
from the `tests/` directory! If not, errors will occur due to erroneous paths, especially in the tests of a solver wrapper.

Let us consider the Abaqus unit test as an example. It is located in `tests/solver_wrappers/abaqus/test_v614.py`. In this file,
there are two `test_classes`, `TestSolverWrapperAbaqus614Tube2D` and `TestSolverWrapperAbaqus614Tube3D`, which inherits from the former.
Within these `test_classes`, four `test_method` are run: `test_repeat_iteration`, `test_restart`, `test_partitioning` and 
`test_shear`. The other two methods, `setUpClass` and `setUp` are run just before each `test_class` and `test_method`, respectively.

If one wants to test this entire file, type following command in the terminal:

 ````
 python -m unittest -bv solver_wrappers/abaqus/test_v614.py
 ````
 
 This will run both `test_classes` and all four `test_methods` for each `test_class`. The `-b` and `-v` keywords have the same meaning 
 as above. If one wants to test for example only the 2D `test_class`, type the following command in the terminal:
 
  ````
  python -m unittest -bv solver_wrappers.abaqus.test_v614.TestSolverWrapperAbaqus614Tube2D
  ````

Note the `.` instead of the `/` to separate the folders since now classes are considered rather than files. This command 
will cause Python to run all four `test_methods` from the 2D `test_class`. Finally, it is also possible to run a single 
`test_method` as well. Consider one wants to test only the correct partitioning of the Abaqus solver over multiple cores 
in the 3D `test_class`, type following command in the terminal:

  ````
  python -m unittest -bv solver_wrappers.abaqus.test_v614.TestSolverWrapperAbaqus614Tube3D.test_partitioning
  ````

Here, only the `test_method` `test_partitioning` is run in the `TestSolverWrapperAbaqus614Tube3D` class. Note that when 
running `test_classes` or `test_methods` of a `solver_wrapper` separately as described in this paragraph, you can discard 
the steps in the previous [paragraph](#including-unit-tests-for-solver-wrappers).